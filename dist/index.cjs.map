{"version":3,"sources":["../utils.ts","../type.ts","../client/index.ts","../pod/index.ts","../server/index.ts","../server/tokenManager.ts"],"names":["z","token","io","Connect","data","nanoid","filter","take","Multicast"],"mappings":"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","sourcesContent":["import { z, ZodType } from \"zod\"\r\nimport type { Socket, RemoteSocket } from \"socket.io\"\r\nimport type { Socket as CSocket } from \"socket.io-client\"\r\nimport type { DefaultEventsMap } from \"socket.io/dist/typed-events\"\r\nimport { allType, IO } from \"./type\";\r\n\r\n// 解析 zod 函数为 IO type\r\nexport const parseZodFunc = (zodFunc: string): Promise<IO> => (new (Object.getPrototypeOf(async function () { }).constructor)(\"z\", `return await (${zodFunc})(z)`))(z)\r\n\r\nexport const parseZodObjectFunc = async (obj: { [key: string]: string }) => {\r\n    const nobj: { [key: string]: IO } = {}\r\n    for (const [key, value] of Object.entries(obj)) {\r\n        nobj[key] = await parseZodFunc(value)\r\n    }\r\n    return nobj\r\n}\r\n\r\n// 构造数据发送器\r\nexport const newSend = (socket: Socket | RemoteSocket<DefaultEventsMap, any> | CSocket, timeout = 3000) => socket[\"sendMsg\"] = (data: z.infer<typeof allType>) =>\r\n    new Promise<void>(async (ok, rj) => {\r\n        try {\r\n            socket.timeout(timeout).emit(\"msg\", await allType.parseAsync(data))\r\n            ok()\r\n        } catch (error) {\r\n            rj(error)\r\n        }\r\n    })\r\n\r\nexport interface Hooks {\r\n    [key: string]: ReturnType<typeof newHook>\r\n}\r\n\r\nexport const newHook = <I extends ZodType, O extends ZodType>(u: {\r\n    io: (z: typeof import(\"zod\").z) => {\r\n        input: I,\r\n        output: O\r\n    }\r\n    func: (input: z.infer<I>) => Promise<z.infer<O> | void> | z.infer<O> | void\r\n}) => u\r\n","import { Socket } from \"socket.io\"\r\nimport { ZodType } from \"zod\"\r\nimport { z } from \"zod\"\r\n\r\nexport interface CentralSocket extends Socket {\r\n    type: \"pod\" | \"client\"\r\n}\r\n\r\n// RPC 函数的出入参\r\nexport interface IO {\r\n    input: ZodType,\r\n    output: ZodType\r\n}\r\n\r\nexport interface ClientHook {\r\n    id: string,\r\n    hooks: { [key: string]: IO }\r\n}\r\n\r\nconst baseType = z.object({\r\n    // 数据包 ID\r\n    id: z.string().length(21),\r\n})\r\n\r\n// 调用类型\r\nexport const callType = baseType.extend({\r\n    type: z.enum([\"call\"]),\r\n    data: z.object({\r\n        func: z.string(),\r\n        input: z.any()\r\n    })\r\n})\r\n\r\n// 返回类型\r\nexport const returnType = baseType.extend({\r\n    type: z.enum([\"return\"]),\r\n    data: z.object(\r\n        {\r\n            func: z.string(),\r\n            status: z.enum([\"success\"]),\r\n            output: z.any()\r\n        }\r\n    ).or(z.object(\r\n        {\r\n            func: z.string(),\r\n            status: z.enum([\"error\"]),\r\n            error: z.object({\r\n                name: z.string(),\r\n                message: z.string().optional(),\r\n                stack: z.string().optional()\r\n            })\r\n        }\r\n    ))\r\n})\r\n\r\nexport const allType = z.union([callType, returnType])\r\n","import { newSend, parseZodObjectFunc } from \"../utils\";\r\nimport { nanoid } from \"nanoid\";\r\nimport { io } from \"socket.io-client\";\r\nimport { Multicast } from \"queueable\";\r\nimport { z } from \"zod\";\r\nimport { allType, ClientHook } from \"../type\"\r\nimport { filter, take } from \"streaming-iterables\";\r\n\r\nexport default function Connect({ uri, token }: { uri: string, token: string }) {\r\n    const msgChannel = new Multicast<z.infer<typeof allType>>()\r\n    const socket = io(uri, { auth: { type: \"client\", token: token } });\r\n    const send = newSend(socket)\r\n    const getHooks = async (msg_id = nanoid()) => {\r\n        const subscription = filter((v) => v.id === msg_id, msgChannel[Symbol.asyncIterator]())\r\n        await send({\r\n            id: msg_id,\r\n            type: \"call\",\r\n            data: { func: \"__meta__\" }\r\n        })\r\n        const first = await subscription.next()\r\n        const len: number = first.value.data.output.sockets.length\r\n\r\n        return {\r\n            clients: first.value.data.output.sockets as string[],\r\n            hooks: {\r\n                [Symbol.asyncIterator]: async function* (): AsyncGenerator<ClientHook> {\r\n                    yield {\r\n                        ...first.value.data.output.hook.data.output,\r\n                        hooks: await parseZodObjectFunc(first.value.data.output.hook.data.output.hooks)\r\n                    }\r\n                    for await (const hook of take(len - 1, subscription)) {\r\n                        yield {\r\n                            ...(hook as any).data.output.hook.data.output,\r\n                            hooks: await parseZodObjectFunc((hook as any).data.output.hook.data.output.hooks)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    socket.on(\"msg\", async (data) => msgChannel.push(await allType.parseAsync(data)))\r\n    return { getHooks }\r\n}","\r\nimport { Channel } from \"queueable\"\r\nimport { z } from \"zod\"\r\nimport { io } from \"socket.io-client\";\r\nimport { Hooks, newHook, newSend } from \"../utils\";\r\nimport { allType } from \"../type\"\r\nexport { newHook }\r\n\r\nexport default function Connect(uri: string, hooks: Hooks = {}) {\r\n    const socket = io(uri, { auth: { type: \"pod\", token: \"\" } });\r\n    socket.compress(true)\r\n    const msgChannel = new Channel<z.infer<typeof allType>>()\r\n    const meta = new Map(Object.entries(hooks))\r\n    const send = newSend(socket)\r\n\r\n    meta.set(\"__meta__\", newHook({\r\n        io: (z) => {\r\n            return {\r\n                input: z.void(),\r\n                output: z.object({\r\n                    id: z.string(),\r\n                    hooks: z.record(z.string(), z.string()),\r\n                })\r\n            };\r\n        },\r\n        func: (_) => {\r\n            const output = {\r\n                id: socket[\"id\"],\r\n                hooks: {}\r\n            }\r\n            for (const [key, value] of meta) {\r\n                // 去掉隐藏函数\r\n                if (!(key.endsWith(\"__\") && key.startsWith(\"__\"))) {\r\n                    output.hooks[key] = value.io.toString()\r\n                }\r\n            }\r\n            return output\r\n        }\r\n    }))\r\n\r\n    socket.on(\"msg\", async (data) => {\r\n        const msg = await allType.parseAsync(data)\r\n        if (msg.type === \"call\") {\r\n            const hook = meta.get(msg.data.func)\r\n            if (hook) {\r\n                const { input, output } = hook.io(z)\r\n                // 校验输入\r\n                const parsedInput = await input.safeParseAsync(msg.data.input)\r\n                if (parsedInput.success) {\r\n                    // 运行 func 并校验输出\r\n                    try {\r\n                        const data = await hook.func(parsedInput.data)\r\n                        const outdata = await output.safeParseAsync(data)\r\n                        if (outdata.success) {\r\n                            await send({\r\n                                id: msg.id,\r\n                                type: \"return\",\r\n                                data: {\r\n                                    func: msg.data.func,\r\n                                    status: \"success\",\r\n                                    output: outdata.data\r\n                                }\r\n                            })\r\n                        } else {\r\n                            // 输出校验失败\r\n                            console.log(\"输出校验失败\")\r\n                        }\r\n                    } catch (error) {\r\n                        // 函数运行错误\r\n                        console.log(\"函数运行错误\")\r\n                    }\r\n                } else {\r\n                    // 校验失败 输入校验失败\r\n                    console.log(\"输入校验失败\")\r\n                }\r\n            } else {\r\n                // 404 未找到 called func\r\n                console.log(\"未找到 called func\")\r\n            }\r\n        } else if (msg.type === \"return\") {\r\n            // 处理 return\r\n            await msgChannel.push(msg)\r\n        }\r\n    })\r\n\r\n    return msgChannel.wrap()\r\n}\r\n","import type { Server } from \"socket.io\"\r\nimport { newSend } from '../utils';\r\nimport { nanoid } from \"nanoid\"\r\nimport { filter, take } from \"streaming-iterables\"\r\nimport { Multicast } from 'queueable';\r\nimport { allType } from '../type';\r\nimport { z } from 'zod';\r\nimport TM from \"./tokenManager\"\r\n\r\nexport default function serve(wss: Server) {\r\n    wss.compress(true)\r\n    const msgChannel = new Multicast<z.infer<typeof allType>>()\r\n    const tm = TM()\r\n    // 获取所有 Pod 的 meta\r\n    const getHooks = async (msg_id = nanoid()) => {\r\n        const sockets: string[] = []\r\n        for (const socket of await wss.fetchSockets()) {\r\n            if (socket[\"type\"] === \"pod\") {\r\n                sockets.push(socket.id)\r\n                const send = newSend(socket)\r\n                await send({\r\n                    id: msg_id,\r\n                    type: \"call\",\r\n                    data: { func: \"__meta__\" }\r\n                })\r\n            }\r\n        }\r\n        return { sockets, hooksIter: take(sockets.length, filter((v) => v.id === msg_id, msgChannel[Symbol.asyncIterator]())) }\r\n    }\r\n    // 处理 client 信息\r\n    const porcessClientMsg = async (msg: z.infer<typeof allType>, send: ReturnType<typeof newSend>) => {\r\n        if (msg.type === \"call\") {\r\n            if (msg.data.func === \"__meta__\") {\r\n                // 收集并发送所有 meta\r\n                const { sockets, hooksIter } = await getHooks(msg.id)\r\n                for await (const hook of hooksIter) {\r\n                    await send({\r\n                        id: msg.id,\r\n                        type: \"return\",\r\n                        data: {\r\n                            status: \"success\",\r\n                            func: msg.data.func,\r\n                            output: { sockets, hook }\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 认证连接\r\n    wss.use(async (socket, next) => {\r\n        const res = await tm.valid(socket.handshake.auth)\r\n        if (res === false) {\r\n            next(new Error(\"not authorized\"))\r\n        } else {\r\n            socket[\"type\"] = res\r\n            console.log(socket.id, res, \"已连接\")\r\n            next()\r\n        }\r\n    });\r\n\r\n    wss.on('connection', async (socket) => {\r\n        const send = newSend(socket)\r\n        socket.on(\"disconnect\", (reason) => console.log(socket[\"id\"], (socket[\"type\"] === \"client\" ? \"客户端\" : \"Pod\") + \"已关闭:\", reason));\r\n        socket.use(async ([event, data], next) => {\r\n            if (event === \"msg\") {\r\n                const result = await allType.safeParseAsync(data)\r\n                if (result.success === true) {\r\n                    const msg = result.data\r\n                    switch (socket[\"type\"]) {\r\n                        case \"client\":\r\n                            await porcessClientMsg(msg, send)\r\n                            break;\r\n\r\n                        case \"pod\":\r\n                            msgChannel.push(msg)\r\n                            break;\r\n\r\n                        default:\r\n                            console.log(\"未知 socket 类型:\", socket[\"type\"])\r\n                            socket.disconnect()\r\n                    }\r\n                } else {\r\n                    next(result.error)\r\n                }\r\n            }\r\n        })\r\n    })\r\n}\r\n","import { z } from \"zod\"\r\n\r\nconst token = [\"token\"]\r\n\r\nconst AuthMsg = z.object({\r\n    type: z.enum([\"client\", \"pod\"]),\r\n    token: z.string()\r\n})\r\n\r\nexport default () => {\r\n    return {\r\n        valid: async (msg: unknown) => {\r\n            const data = await AuthMsg.safeParseAsync(msg)\r\n            if (data.success) {\r\n                switch (data.data.type) {\r\n                    case \"client\":\r\n                        return token.includes(data.data.token) ? \"client\" : false\r\n                    case \"pod\":\r\n                        return \"pod\"\r\n                }\r\n            } else return false\r\n        }\r\n    }\r\n}"]}